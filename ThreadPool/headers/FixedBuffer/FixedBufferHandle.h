#ifndef OK_FIXEDBUFFERHANDLE_INCLUDED
#define OK_FIXEDBUFFERHANDLE_INCLUDED
/*
 * This Code is edited by sun wukong @ 2015.12.30 15:14:12 CST 
 * 
 * Just feel free to use this code as you wish.
 * Any bug and ugly code, please notify me, thanks!
 *
 * Github https://githuc.com/maybe2009
 * Gmail  qtdssunwukong@gmail.com
 * 									-Auto Generated By UltiSnips
 */

#include <iostream>
#include <memory>
#include <unistd.h>
#include <string.h>
#include <boost/ptr_container/ptr_vector.hpp>
#include <boost/ptr_container/ptr_deque.hpp>
#include <boost/ptr_container/ptr_list.hpp>
#include <boost/noncopyable.hpp>
#include <vector>
#include "FixedBuffer.h"
#include "../Synchronization/Mutex.h"
#include "../Synchronization/Condition.h"

namespace ok{

class FixedBufferHandle : boost::noncopyable
{
public: /*type defines*/
    typedef boost::ptr_list<FixedBuffer>        BufferContainer;
    typedef BufferContainer::auto_type          BufAutoPtr;
    typedef BufferContainer*                    ContainerPtr;

public: /*Constructions etc*/
    FixedBufferHandle(size_t buf_size, size_t max_buf_size = 8, size_t chunk = 4)
        : bufferSize_(buf_size),
          chunkSize_(chunk),
          chunkNum_(4),
          maxBufSize_(max_buf_size),
          currentBufSize_(0),
          overflowCount_(0),
          
          currentBuf_(new FixedBuffer(buf_size)),
          supportBuf_(new FixedBuffer(buf_size)),
          
          dutyQueue_(),
          readyQueue_(),
          cleanQueue_(),
          supportQueue_(),
          
          dutyQueuePtr_(&dutyQueue_),
          readyQueuePtr_(&readyQueue_),
          cleanQueuePtr_(&cleanQueue_),
          supportQueuePtr_(&supportQueue_),
          
          mutex_(),
          cond_(mutex_)
    {
        /*
        dutyQueue_.reserve(chunkNum_);
        readyQueue_.reserve(chunkNum_);
        cleanQueue_.reserve(chunkNum_);
        supportQueue_.reserve(chunkNum_);
        */
        allocate();
    } 
     
    /*
     * Copy constructor must be declared as delete to avoid compile errors,
     * because auto_type(BufAutoPtr) in boost is uncopyable 
     */    
    FixedBufferHandle (const FixedBufferHandle&) = delete; 
    
public: /*handle size_terfaces for users*/
    void doFrontWrite(const char * buf, size_t len)
    {
        ScopeMutex lock(mutex_);
        
        if (currentBuf_->getAvailable() > len)
        {
            currentBuf_->write(buf, len);
        }
        else
        {
            pushCurrentBufDuty();
            getNewCurrentBuf();
            currentBuf_->write(buf, len);
            cond_.signal();
        }
        show();
    }
    
    
    void doBackGround()
    {
        while(1)
        {
            {   /*Just a swap to make criticle section short*/
                ScopeMutex lock(mutex_);
                while(dutyQueuePtr_->empty())
                {
                    cond_.wait();
                }
                pushCurrentBufDuty();
                getNewCurrentBuf();
                swapDuty();
            }
            
            /*Write file operation may take a long time*/
            handleDuty();
            
            {
                /*Constant complexcity splice*/
                ScopeMutex lock(mutex_);
                spliceClean();
                ss();
            }
        }
    }
     
    /* TODO delete show() ss() after debug*/
    void show()
    {
        std::cout << "...Add..." << std::endl;
        currentBuf_->show();    
        std::cout << "Duty Queue Size: "  << dutyQueuePtr_->size() << std::endl;
        std::cout << "Ready Queue Size: " << readyQueuePtr_->size() << std::endl;
        std::cout << "Clean Queue Size: " << cleanQueuePtr_->size() << std::endl;
        std::cout << "Support Queue Size: " << supportQueuePtr_->size() << std::endl;
        std::cout << "****************************************************" << std::endl;
    
    }
    
    void ss()
    {
        std::cout << "...Moving..." << std::endl;
        currentBuf_->show();    
        std::cout << "Duty Queue Size: "  << dutyQueuePtr_->size() << std::endl;
        std::cout << "Ready Queue Size: " << readyQueuePtr_->size() << std::endl;
        std::cout << "Clean Queue Size: " << cleanQueuePtr_->size() << std::endl;
        std::cout << "Support Queue Size: " << supportQueuePtr_->size() << std::endl;
        std::cout << "****************************************************" << std::endl;

    }

private: /*utility functions*/
    
    /**
     * @brief Push current buffer to duty queue
     */
    void pushCurrentBufDuty()
    {
        dutyQueuePtr_->push_back(currentBuf_.release());
        currentBuf_.swap(supportBuf_);
    } 
    
    void getNewCurrentBuf()
    {
        supportBuf_ = supportQueuePtr_->pop_front();
    }
    
    void swapDuty()
    {
        ContainerPtr tmp = dutyQueuePtr_ ;
        dutyQueuePtr_    = readyQueuePtr_;
        readyQueuePtr_   = tmp;
    }
    
    void handleDuty()
    {
        BufAutoPtr tmp;

        while(!readyQueuePtr_->empty())
        {
            tmp = readyQueuePtr_->pop_front();
            cleanQueuePtr_->push_back(tmp.release());
        }
    }

    void spliceClean()
    {
        supportQueuePtr_->transfer(supportQueuePtr_->begin(), *cleanQueuePtr_);
    }
    
    void allocate()
    {
        size_t sizeNeeded;
        
        sizeNeeded = chunkSize_ * bufferSize_;
        if ((currentBufSize_ + sizeNeeded) <= maxBufSize_) 
        {
            size_t i;
            for (i = 0; i < chunkNum_; ++i) 
            {
                supportQueuePtr_->push_back(new FixedBuffer(bufferSize_));
                std::cout << "+++" << std::endl;
                currentBufSize_ += bufferSize_;
            }             
        } 
        else
        {
            overflowCount_++;
            return;
        }
    }

private:
    size_t                 bufferSize_;
    size_t                 chunkSize_;
    size_t                 chunkNum_;
    size_t                 maxBufSize_;
    size_t                 currentBufSize_;
    size_t                 overflowCount_;
    
    BufAutoPtr          currentBuf_;
    BufAutoPtr          supportBuf_;
    
    BufferContainer     dutyQueue_;
    BufferContainer     readyQueue_;
    BufferContainer     cleanQueue_;
    BufferContainer     supportQueue_;
    
    ContainerPtr        dutyQueuePtr_;
    ContainerPtr        readyQueuePtr_;
    ContainerPtr        cleanQueuePtr_;
    ContainerPtr        supportQueuePtr_;
 
    Mutex               mutex_;
    Condition           cond_;
};
};
#endif /* ifndef OK_FIXEDBUFFERHANDLE_INCLUDED*/

