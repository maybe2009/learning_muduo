#ifndef OK_FIXEDBUFFERHANDLE_INCLUDED
#define OK_FIXEDBUFFERHANDLE_INCLUDED
/*
 * This Code is edited by sun wukong @ 2015.12.30 15:14:12 CST 
 * 
 * Just feel free to use this code as you wish.
 * Any bug and ugly code, please notify me, thanks!
 *
 * Github https://githuc.com/maybe2009
 * Gmail  qtdssunwukong@gmail.com
 * 									-Auto Generated By UltiSnips
 */

#include <iostream>
#include <memory>
#include <unistd.h>
#include <string.h>
#include <boost/ptr_container/ptr_vector.hpp>
#include <boost/ptr_container/ptr_deque.hpp>
#include <boost/ptr_container/ptr_list.hpp>
#include <boost/noncopyable.hpp>
#include <vector>
#include <assert.h>

#include "FixedBuffer.h"
#include "../Synchronization/Mutex.h"
#include "../Synchronization/Condition.h"

namespace ok{

class FixedBufferHandle : boost::noncopyable
{
public: /*type defines*/
    typedef boost::ptr_list<FixedBuffer>        BufferContainer;
    typedef BufferContainer::auto_type          BufAutoPtr;
    typedef BufferContainer*                    ContainerPtr;

public: /*Const
 * ructions etc*/
    FixedBufferHandle(size_t buf_size):
        bufferSize_(buf_size),
        fd_(-1),

        currentBuf_(new FixedBuffer(buf_size)),
        dutyQueue_(),
        cleanQueue_(),
      
        dutyQueuePtr_(&dutyQueue_),
        cleanQueuePtr_(&cleanQueue_),
      
        mutex_(),
        cond_(mutex_),
        currentBufferNum_(1)

    {
        init();
    } 
     
    /*
     * Copy constructor must be declared as delete to avoid compile errors,
     * because auto_type(BufAutoPtr) in boost is uncopyable 
     */    
    FixedBufferHandle (const FixedBufferHandle&) = delete; 
    
public: /*handle size_terfaces for users*/
    void doFrontWrite(const char * buf, size_t len)
    {
        ScopeMutex lock(mutex_);     
        assert(currentBuf_ != nullptr);
        /*if current buffer is sufficent, just wrtie, otherwise, perform reload
         * operations
         */
        if (currentBuf_->getAvailable() < len)
        {
            std::cout << "Current buffer is not sufficent, perform reloading" << std::endl;
            enqueueDuty();
           
            /*if clean queue is empty allocate one FixedBuffer*/ 
            if(cleanQueuePtr_->empty())
            {
                std::cout << "Clean queue is empty, allocating..." << std::endl;
                if(allocate(1))
                {
                    std::cout << "Reloading..." << std::endl;
                    reloadCurrentBuf();
                    currentBuf_->write(buf, len);
                }
                else
                {
                    std::cout << "Allocate fail, handling..." << std::endl;
                    handleLackofCleanBuf();
                    currentBuf_->write(buf, len);
                } 
            }
            else
            {
                std::cout << "Reloading..." << std::endl;
                reloadCurrentBuf();
                currentBuf_->write(buf,len);
            }  
        }
        else
        {
            currentBuf_->write(buf, len);
        }    
        
        std::cout << "Write completed! Signal!" << std::endl; 
        cond_.signal();
    }
     
    void doBackGround()
    {
        if(fd_ < 0)
        {
            return;
        }

        while(1)
        {
            {   /*Just a pop operation to make criticle section short*/
                std::cout << "doBackGround acquire lock" << std::endl;
                ScopeMutex lock(mutex_);
                while(dutyQueuePtr_->empty())
                {
                    std::cout << "Duty queue is empty, sleep..." << std::endl;
                    cond_.wait();
                    std::cout << "Sigal received! Wake up!" << std::endl;
                }
                std::cout << "Dequeue writting buffer" << std::endl;
                dequeuDuty();
            }
            
            std::cout << "Perform writting to file .... " << std::endl;
            //assert(!writtingBuf_.empty()); 
            dumpWrittingBuf();
            std::cout << "Writting to file completed!" << std::endl;

            {   /*Write operation over, push back writting buffer to clean queue*/
                ScopeMutex lock(mutex_);
                std::cout << "Enqueue writting buffer" << std::endl;
                enqueueClean();
            }
        }
    }
    
    void setFileDescriptor(int fd)
    {
        fd_ = fd;
    }    

    /* TODO delete show() ss() after debug*/
    void show()
    {
        std::cout << "...Add..." << std::endl;
        currentBuf_->show();    
        std::cout << "Duty Queue Size: "  << dutyQueuePtr_->size() << std::endl;
        std::cout << "Clean Queue Size: " << cleanQueuePtr_->size() << std::endl;
        std::cout << "****************************************************" << std::endl;
    
    }
    
    void ss()
    {
        std::cout << "...Moving..." << std::endl;
        currentBuf_->show();    
        std::cout << "Duty Queue Size: "  << dutyQueuePtr_->size() << std::endl;
        std::cout << "Clean Queue Size: " << cleanQueuePtr_->size() << std::endl;
    }

private: /*utility functions*/
    void init()
    {
        chunkSize_ = 4;
        maxBufferNum_ = 10;
    }

    void enqueueDuty()
    {
        /*push current buffer to duty queue*/
        dutyQueuePtr_->push_back(currentBuf_.release());
    }
    
    void reloadCurrentBuf()
    {
        /*get new current buffer*/
        currentBuf_ = cleanQueuePtr_->pop_front(); 
    }    

    void handleLackofCleanBuf()
    {
        reloadFromDutyQueueHead();
    }

    void reloadFromDutyQueueHead()
    {
        currentBuf_ = dutyQueuePtr_->pop_front();
        currentBuf_->clear();
    }

    void reloadFromDutyQueueTail()
    {
        currentBuf_ = dutyQueuePtr_->pop_back();
        currentBuf_->clear();
    }

    void dequeuDuty()
    {
        /*get the first duty buffer*/
        writtingBuf_ = dutyQueuePtr_->pop_front();
    }
    
    void dumpWrittingBuf()
    {
        writtingBuf_->dump(fd_);
        writtingBuf_->clear();
    }

    void enqueueClean()
    {
        /*push writting buffer to clean buffer queue*/
        cleanQueuePtr_->push_back(writtingBuf_.release());       
    }
    
    bool allocate(size_t num)
    {
        if (currentBufferNum_ + num <= maxBufferNum_)
        {
            for (size_t i = 0; i < num; ++i)
            {
                cleanQueuePtr_->push_back(new FixedBuffer(bufferSize_)); 
                currentBufferNum_++;
            }

            return true;
        }
        else 
        {
            return false;
        }
    }

private:
    size_t                 bufferSize_;
    int                    fd_;

    BufAutoPtr          currentBuf_;
    BufAutoPtr          writtingBuf_;

    BufferContainer     dutyQueue_;
    BufferContainer     cleanQueue_;
    
    ContainerPtr        dutyQueuePtr_;
    ContainerPtr        cleanQueuePtr_;
 
    Mutex               mutex_;
    Condition           cond_;

public:
    size_t                 chunkSize_;
    size_t                 maxBufferNum_;
    size_t                 currentBufferNum_;

};//class FixedBufferHandle

};//namespace ok
#endif /* ifndef OK_FIXEDBUFFERHANDLE_INCLUDED*/

