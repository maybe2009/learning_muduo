/*
 * This Code is edited by sun wukong @ 2015.12.16 14:57:00 CST 
 * 
 * Just feel free to use this code as you wish.
 * Any bug and ugly code, please notify me, thanks!
 *
 * Github https://githuc.com/maybe2009
 * Gmail  qtdssunwukong@gmail.com
 * 									-Auto Generated By UltiSnips
 */


/**
 * @brief
 * The Two Phase cover-launch method 
 * 
 * In Linux, API "pthread_create" has the prototype of ---
 * 
 * int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
 *                    void *(*start_routine)(void*), void *arg  )
 * 
 * As a C style API, it requires a function pointer of type void (foo*)(void*)
 * . It's not convenient in C++ using this native C style API. So, we 
 * need to wrap this.
 *
 * The way we approach it is called cover-launch. And, it's a two phase operat
 * -ion including Cover phase and Launch phase. Cover phase deals with the ann
 *  -oying "pthread_create", while launch does the work.
 *
 * Phase Cover:
 *  
 *  When creating a thread with "pthread_create", a "cover" function 
 *  of type void (foo*)(void*) will be passed as the third argument to
 *  "pthread_create". 
 
 *  Then, we pass a argument of type void* to "cover" function in as the
 *  4th argument of "pthread_create" API. Here, we will pass a pointer of 
 *  class RoutineLauncher(The one "cover" function covers). Within this 
 *  pointer, we start the Launch phase.  
 *
 *  Finally, "cover" function will be executed in the 
 *  new thread as "pthread_create" returned in another. 
 *
 * 
 * Phase Launch:
 *
 *  In this phase, we just make a call on the class RoutineLauncher pointer 
 *  to start routine A. RoutineLauncher takes care everthing to start routine 
 *  A. 
 * 
 */


/**
 * @brief
 * A class RoutineLauncher object is responsible 
 * for carrying the excution to the expected function. That is 
 * to say, "launch" the expected function.
 *
 * Also, RoutineFunction is responsible for manage the routine with
 * it's arguments. 
 *
 * Member variable func_ is a boost::function object. func_ is
 * the function we want to run in a specific thread.  
 */


/**
 * @brief 
 *  coverFunction will be passed as the argument --- "start_rountine"  
 *  to function "pthread_create".
 *
 *  Once "pthread_create" is excuted, coverFunction make a call ---
 *  ptr->Launch. In Launch, the indeed and exact RoutineLauncher of this 
 *  just created thread shall run. 
 *   
 * @param RoutineLauncher
 *  RoutineLauncher points to the exact routine 
 *
 * @return
 *   
 */

/**
 * @brief 
 * Constructor of RoutineLauncher
 *
 * @param func
 * boost::function object of which attach to the routine run in the Thread
 *
 * @param args
 */


/**
 * @brief 
 * Launch the routine with specific arguments
 */

#ifndef OK_THREAD_INCLUDED
#define OK_THREAD_INCLUDED

#include <pthread.h>
#include <unistd.h>
#include <string>
#include <sys/types.h>
#include <sys/syscall.h>
#include <linux/unistd.h>
#include <memory>
#include <boost/noncopyable.hpp>
#include <boost/function.hpp>
#include <iostream>

namespace ok {
	typedef boost::function<void(void *)> RoutineFunction;

	class VoidDeleter {
	public:
		template <typename T>
		void operator()(T *p)
		{return;}
	};

	class RoutineLauncher {
	public:
		RoutineLauncher(const RoutineFunction func, std::unique_ptr<void, VoidDeleter> &&args);

		void Launch();

	private:
		std::unique_ptr<void, VoidDeleter> args_;
		RoutineFunction func_;
	};

	class Thread : public boost::noncopyable {
	public:
		Thread(RoutineFunction &fun);

		Thread(RoutineFunction &fun,
		       std::unique_ptr<void, VoidDeleter> &&args,
		       std::unique_ptr<pthread_attr_t> &&attr,
		       std::string name);

		~Thread();

	public:
		void run();

		void ook(int i);

		void join(void **_rval_ptr = NULL);

		void cancel(pthread_t threadID);

		void printName();

	private:
		std::unique_ptr<void, VoidDeleter> args_;
		bool isRunning_;
		bool isJoined_;
		pthread_t id_;
		RoutineFunction func_;
		std::unique_ptr<pthread_attr_t> attribute_;
		std::string name_;
	};

	void *coverFunction(void *launcher);
};//namespace okay

#endif
