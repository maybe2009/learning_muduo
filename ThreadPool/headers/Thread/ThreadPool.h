/*
 * This Code is edited by sun wukong @ 2015.12.23 17:47:45 CST 
 * 
 * Just feel free to use this code as you wish.
 * Any bug and ugly code, please notify me, thanks!
 *
 * Github https://githuc.com/maybe2009
 * Gmail  qtdssunwukong@gmail.com
 * 									-Auto Generated By UltiSnips
 */

#ifndef OK_THREADPOOL_INCLUDED
#define OK_THREADPOOL_INCLUDED

#include <vector>
#include <deque>
#include <boost/bind.hpp>
#include <boost/noncopyable.hpp>
#include <boost/ptr_container/ptr_vector.hpp>

#include "Thread.h"
#include "Mutex.h"
#include "Condition.h"
#include "AtomicInteger.h"

namespace ok{
class ThreadPool : public boost::noncopyable 
{
public:
typedef boost::function<void ()> Task;

public:
    ThreadPool(int);
    
    void    startNThread(int num); 
    void    addTask(const Task& task);
    void    stop();
    int     numRunning();
    int     numWaiting();

private:
    void worker(void *);
    Task getTask();
    
private:
    int                             capacity_;
    AtomicInt32                     runningThreads_;
    AtomicInt32                     waitingThreads_;
    boost::ptr_vector<ok::Thread>   threads_;    
    std::deque<Task>                tasks_;
    Mutex                           mutex_;
    Condition                       cond_;
    bool                            isRunning_;
};

inline ThreadPool::
ThreadPool(int capcity)
    : capacity_(capcity),
      runningThreads_(0),
      waitingThreads_(0),
      tasks_(),
      mutex_(),
      cond_(mutex_),
      isRunning_(false)
{}

inline int ThreadPool::
numRunning()
{
    return runningThreads_.get();
}

inline int ThreadPool::
numWaiting()
{
    return waitingThreads_.get();
}

inline void ThreadPool::
startNThread(int thread_num)
{
    if (threads_.empty()) {
        isRunning_ = true;
        threads_.reserve(thread_num);
        
        for (int i = 0; i < thread_num; ++i) {
            threads_.push_back(new Thread(
                boost::bind(&ThreadPool::worker, this, _1)));  
            threads_[i].run();  
        }
    }
}

inline void ThreadPool::
addTask(const Task& task)
{
    ScopeMutex lock(mutex_); 
    tasks_.push_back(task);
    cond_.signal();
}

inline void ThreadPool::
worker(void *)
{
    Task task;
    while (isRunning_) {
        task = getTask(); 
        if (task) {
            task();
        }     
    }
    
    std::cout << ThreadLocal::threadID << std::endl; 
}

/*
 * getTask(): 
 * Wake up for 2 reasons :
 * 1. Available tasks
 * 2. ThreadPool::stop is called
 *
 * Return valid task for only one reason:
 * There are available tasks and ThreadPool is running
 */ 
inline ThreadPool::Task ThreadPool::
getTask()
{
    ScopeMutex lock(mutex_);
    while (tasks_.empty() && isRunning_) {
        std::cout << "Thread " << ThreadLocal::threadID << " is watting." << std::endl; 
        waitingThreads_.increment();
        cond_.wait();  
        waitingThreads_.decrement();
    }
    
    Task ret; 
    if (!tasks_.empty() && isRunning_) {
        ret = tasks_.front();
        tasks_.pop_front();
    }
    
    std::cout << "Thread " << ThreadLocal::threadID << " is going to running" << std::endl;
    return ret;
}

inline void ThreadPool::
stop()
{
    if (isRunning_) {
        isRunning_ = false;
        cond_.broadcast();

        for (auto it = threads_.begin(); it != threads_.end(); ++it) {
            it->join(nullptr); 
        }
    }

}

};
#endif /* ifndef OK_THREADPOOL_INCLUDED */
